<HTML>
	<HEAD>
		<TITLE>inevitable_cube</TITLE>

		<!--  B I T  -  O '  -  J A V A S C R I P T : bit o' javascript -->

		<script type="text/javascript" src="Trianglo.js"></script>

		<script type="text/javascript">
			const SQRT_3 = Math.sqrt( 3 );
			const INVERSE_SQRT_3 = 1 / SQRT_3;

			const makeCube = function() {
				let cube = {
					  points:[]
					, vertices:[]
					, faces:[]
					, edges:[]
					, triangles:[]
					, normals:[]
					, centroids:[]
				};

				for ( let i = 0 ; i < 8 ; i++ ) {
					cube.points.push(
						( '00' + i.toString( 2 ) )
						.substr( -3 )
						.replace( /(.)/g, '$1 ' )
						.replace( /0/g, '-1' )
						.trim()
						.split( ' ' )
						.map( function( v ) { return v * INVERSE_SQRT_3 }  )
					);
				}

				for ( let dimension = 0 ; dimension < 3 ; dimension++ ) {
					for ( let sign = -1 ; sign <= +1 ; sign += 2 ) {
						let value = sign * INVERSE_SQRT_3;
						let centroid = [0,0,0];
						centroid[ dimension ] = value;
						cube.centroids = cube.centroids.concat( centroid );

						// look for points that match the search criteria
						let indices = [];
						for ( let i = 0 ; i < cube.points.length ; i++ ) {
							let vertex = cube.points[ i ];
							if ( vertex[ dimension ] == value ) {
								indices.push( i );
							}
						}

						// this is a bit wack to avoid bow-ties
						let tmp = indices[ 2 ];
						indices[ 2 ] = indices[ 3 ];
						indices[ 3 ] = tmp

						// use the normal to show the centroid 
						// and debug direction of the faces..
						let normal = Vectoro.normalVector( 
							cube.points[ indices[ 0 ] ],
							cube.points[ indices[ 1 ] ],
							cube.points[ indices[ 2 ] ]
						);	
						cube.normals.push( normal ); // idk what to do with this...
						let c2 = Vectoro.add( Vectoro.scale( 0.13, normal ), centroid );
						cube.centroids = cube.centroids.concat( c2 );

						// guess this is just for fun...
						cube.faces = cube.faces.concat( indices ); 

						// triangle 1
						cube.triangles.push( indices[ 0 ] );
						cube.triangles.push( indices[ 1 ] );
						cube.triangles.push( indices[ 2 ] );

						// triangle 2
						cube.triangles.push( indices[ 2 ] );
						cube.triangles.push( indices[ 3 ] );
						cube.triangles.push( indices[ 0 ] );
					
						// edges are quirky.... need begin and end index
						for ( let i = 0 ; i < indices.length ; i++ ) {
							cube.edges.push( indices[ i ] );
							if ( i ) { 
								cube.edges.push( indices[ i ] );
							}
						}
						cube.edges.push( indices[ 0 ] );
					}
				}

				for ( let i = 0 ; i < cube.points.length ; i++ ) {
					cube.vertices = cube.vertices.concat( cube.points[ i ] );
				}

				cube.centroid_lines = [];
				cube.centroid_colors = [];
				let centroid_count = cube.centroids / 3;
				let orange = [ 1, 1, 0 ];
				cube.centroid_colors = cube.centroid_colors.concat( orange );
				for ( let i = 1 ; i < cube.centroids.length / 3  ; i++ ) {
					cube.centroid_colors = cube.centroid_colors.concat( orange );
					cube.centroid_lines.push( i - 1 );
					cube.centroid_lines.push( i - 0 );
				}

				return cube;
			};

			const inevitable_cube = function() {
				let canvas = document.getElementsByTagName( 'canvas' )[ 0 ];
				let vertexSource = document.getElementById( 'vertex-shader' ).innerHTML;
				let fragmentSource = document.getElementById( 'fragment-shader' ).innerHTML;

				let gl = Trianglo.gl( canvas );

				let program = Trianglo.program( gl, vertexSource, fragmentSource );

				let cube = makeCube();

				let cyans  = cube.vertices.map( function( v, i ) { return i % 3 ? 1 : 0 } );
				let colors = cube.vertices.map( function( v ) { 
					return ( v + INVERSE_SQRT_3 ) / ( INVERSE_SQRT_3 * 2 );
				} );

				let angle = 0;

				let draw = function() {
					angle += 0.033;
					let c = Math.cos( angle );
					let s = Math.sin( angle );

					let x = Matrixo.rotateX( c, s );
					let y = Matrixo.rotateY( c, s );
					let z = Matrixo.rotateZ( c, s );
					let q = Matrixo.scale( 0.66 );

					let m = Matrixo.multiply( Matrixo.multiply( Matrixo.multiply( x, y ), z ), q );
					Trianglo.matrix( gl, program, 'uMatrix', m );

					Trianglo.clear( gl );

					// triangles
					Trianglo.data( gl, program, 'aPosition', cube.vertices );
					Trianglo.data( gl, program, 'aColor', colors );
					Trianglo.draw( gl, cube.triangles );

					// edges
					// this is interesting: https://mattdesl.svbtle.com/drawing-lines-is-hard
					Trianglo.data( gl, program, 'aColor', cyans );
					Trianglo.draw( gl, cube.edges, gl.LINES );

					// draw the normals
					Trianglo.data( gl, program, 'aPosition', cube.centroids );
					Trianglo.data( gl, program, 'aColor', cube.centroid_colors );
					Trianglo.draw( gl, cube.centroid_lines, gl.LINES );

					setTimeout( function() { requestAnimationFrame( draw ) }, 50 );
				}

				draw();

			};

			window.onload = inevitable_cube;
		</script>

		<!--  V E R T E X  -  S H A D E R : vertex shader -->

		<script id="vertex-shader" type="x-shader/x-vertex">
			attribute vec4 aPosition;
			attribute vec4 aColor;

			uniform mat4 uMatrix;
			varying vec4 vColor;
			void main() {
				   gl_Position = uMatrix * aPosition;
				   vColor = aColor;
			}
		</script>

		<!--  F R A G M E N T  -  S H A D E R : fragment shader -->

		<script id="fragment-shader" type="x-shader/x-fragment">
			precision mediump float;
			varying vec4 vColor; 
			void main(void) {
				//gl_FragColor = vec4( 0, 1, 1, 1 );
				gl_FragColor = vColor;
			}
		</script>

		<!--  S O  -  S T Y L I S H ! : so stylish! -->

		<style>
			body {
				background: #444;
			}
			canvas {
				margin:auto;
				margin-top:2em;
				display:block;
				border-top:    3px solid #222;
				border-left:   3px solid #222;
				border-right:  3px solid #666;
				border-bottom: 3px solid #666;
			}
		</style>
	</HEAD>
	<BODY>
		<canvas width="512" height="512"></canvas>
	</BODY>
</HTML>
