<HTML>
	<HEAD>
		<TITLE>boardBuilder</TITLE>

		<style>
			body {
				font-family: Comic Sans MS, sans;
			}
			img {
				display:block;
				position:absolute;
			}
			.r0 { transform: rotate( -0deg ); }
			.r1 { transform: rotate( -60deg ); }
			.r2 { transform: rotate( -120deg ); }
			.r3 { transform: rotate( -180deg ); }
			.r4 { transform: rotate( -240deg ); }
			.r5 { transform: rotate( -300deg ); }
		</style>

		<script type="text/javascript" src="tiles.js"></script>
		<script type="text/javascript" src="directions.js"></script>

		<script type="text/javascript">
			const boardBuilder = function() {
				let start = "Borderland";
				let orientation = Math.floor( 33 * Math.random() ) % 6;
				let placed = [ addTile( start, orientation ) ];

				let unplaced = shuffle( remove( Object.keys( tiles ), start ) );

				for ( let i = 0 ; i < 101 && unplaced.length ; i++ ) {
					unplaced = shuffle( unplaced );

					let pick = randomPick( placed );
					let exits = [];
					for ( let k in pick.exits ) {
						if ( !pick.exits[ k ] ) exits.push( k );
					}
					if ( 0 == exits.length ) {
						//console.log( pick.name + ' has no available exits, moving on...' );
						i--; // don't count this attempt
						continue;
					}

					shuffle( exits );
					console.log( 
						  i+ '> try to place something near ' 
						+ pick.name 
						+ ' @( ' + [pick.x,pick.y].join( ',' ) + ')' 
						+ ' via ' + exits.join( ', ' ) 
					);

					let foundOne = false; 

					for ( let e = 0 ; e < exits.length && !foundOne; e++ ) {
						let exit = exits[ e ];
						let opposing = DIRECTIONS[ exit ].opposing;

						// useless information
						//console.log( '- ' + exit + ' leads to ' + opposing );
						console.log( '- ' + exit + ' vs ' + unplaced.join( ',' ) );

						for ( let j = 0 ; j < unplaced.length ; j++ ) {
							let maybe = unplaced[ j ];
							orientation = Math.floor( 33 * Math.random() ) % 6;
							//snit

							let to = rotateExits( tiles[ maybe ].normal.exits, orientation );
							if ( !( opposing in to ) ) {
								// this is pretty tmi...
								//console.log( '-- ' + maybe + ' tile has no exits headed that way' );
								continue;
							}

							let x = pick.x + DIRECTIONS[ exit ].dx;
							let y = pick.y + DIRECTIONS[ exit ].dy;

							console.log( '-- could be ' + maybe + ' @(' + [x,y] + ') going ' + exit + ' to the ' + opposing );

							foundOne = canPlace( maybe, x, y, to, placed );;
							if ( !foundOne ) {
								console.log( '>> rejecting ' + maybe );
								continue;
							}

							let picked = addTile( maybe, orientation, pick, exit );
							placed.push( picked );
							unplaced = remove( unplaced, maybe );

							console.log( '-> added ' + maybe + ' as #' + placed.length + ' pick' );
							console.log( '> ' +
								pick.name + '@' 
							+ [pick.x,pick.y].join( ',' ) + ' -> ' + exit 
							+ ' -> ' + opposing + ' <- ' + maybe + '@' + [picked.x,picked.y].join( ',' )

							);
							console.log( '-----------------------------------------------------------------------------' );

							break;
						}
						foundOne = false; // maybe this will lead to denser maps?
					}
				}

				showBoard( placed );

				let nfo = document.createElement( 'div' );
				nfo.style.top = '1em';
				nfo.style.left = '1em';
				nfo.style.position = 'absolute';
				nfo.style.zIndex = -33;
				nfo.style.background = 'white';

				nfo.appendChild( document.createTextNode( 'unplaced: ' + unplaced.length + ': ' + unplaced.join( ', ' ) ) );
				document.body.appendChild( nfo );
			};

			const showBoard = function( placed ) {
				//console.log( JSON.stringify( placed ) );

				let w = 497;
                let h = 431;

				let minx = 0;
				let miny = 0;
				for ( let i = 0 ; i < placed.length ; i++ ) {
					if ( placed[ i ].x < minx ) minx = placed[ i ].x;
					if ( placed[ i ].y < miny ) miny = placed[ i ].y;
				}
				console.log( [minx,miny].join( ', ' ) );

				for ( let i = 0 ; i < placed.length ; i++ ) {
					let fun = placed[ i ];
					let tile = tiles[ fun.name ];

					let img = document.createElement( 'img' );
					img.src = tile.normal.image;
					img.style.top  = h * ( -miny + fun.y ) + 'px';
					img.style.left = w * ( -minx + fun.x ) + 'px';
					img.style.width = w + 'px';
					img.style.height = h + 'px';
					img.setAttribute( 'class',  'r' + fun.orientation );
					document.body.appendChild( img );
				};
			};
						
			const canPlace = function( maybe, x, y, exits, placed ) {
				let ok = true;

				// make sure nothing else is already here (oopsie!)
				for ( let i = 0 ; i < placed.length && ok ; i++ ) {
					if ( x == placed[ i ].x && y == placed[ i ].y ) {
						console.log( '>>> ' + maybe + ' would overlay ' + placed[ i ].name + ' at ' + [x,y] );
						ok = false; 
					}
				}

				for ( let direction in DIRECTIONS ) {
					let otherX = x + DIRECTIONS[ direction ].dx;
					let otherY = y + DIRECTIONS[ direction ].dy;
					let other = false;

					let tileExit  = ( direction in exits  ) ? 'exit' : 'non-exit';
					let tmi1 = [maybe,direction,tileExit].join( '.' );

					for ( let i = 0 ; i < placed.length && !other ; i++ ) {
						if ( otherX ==  placed[ i ].x && otherY == placed[ i ].y ) {
							other = placed[ i ];
						}
					}

					if ( !other ) {
						console.log( '---- nothing to check ' + tmi1 + ' -> ' + [otherX,otherY].join( '.' ) );
						continue;
					}

					let opposing = DIRECTIONS[ direction ].opposing;
					let otherExit = ( opposing  in other.exits ) ? 'exit' : 'non-exit';
					let tmi2 = [other.name,opposing,otherExit].join( '.' );

					ok = ( tileExit == otherExit );
					console.log( '---- check ' + tmi1 + ' vs ' + tmi2 + ' -> ' + ok );
					if ( !ok ) break;
				}

				return ok;
			};

			const addTile = function( name, orientation, which, from ) {
				// TODO: handle orientation properly
				let tile = {name:name, x:0, y:0, orientation:orientation, exits:{}};

				if ( from && which ) {
					tile.x = which.x + DIRECTIONS[ from ].dx;
					tile.y = which.y + DIRECTIONS[ from ].dy;

					if ( which.exits[ from ] ) {
						throw which.name + '.' + from + ' leads to ' + which.exits[ from ] + ' already';
					} else {
						which.exits[ from ] = name;
					}
				}

				for ( let k in tiles[ name ].normal.exits ) {
					k = rotateDirection( k, orientation );

					// for sanity check :-P
					//console.log( k + '+' + orientation + ' -> ' + r + ' -> ' + o );

					tile.exits[ k ] = (
						( which && from && k == DIRECTIONS[ from ].opposing ) 
						? which.name
						: false
					);
					
					// TODO: see if any other exits need to be hooked up....
				}
				console.log( '--> ' + JSON.stringify( tile ) );

				return tile;
			};
	
			const rotateDirection = function( direction, orientation ) {
				let rotated = ( DIRECTIONS[ direction ].index + orientation ) % 6;
				let rotateDirection = Object.keys( DIRECTIONS )[ rotated ];

				// for sanity check :-P
				//console.log( direction + '+' + orientation + ' -> ' + rotated + ' -> ' + rotateDirection );
				return rotateDirection;
			};

			const rotateExits = function( exits, orientation ) {
				let rotated = {};
				for ( let direction in exits ) {
					rotated[ rotateDirection( direction, orientation ) ] = exits[ direction ];
				}
				return rotated;
			}

			const shuffle = function( a ) {
				return a.sort((x,y)=>Math.random()-Math.random());
			}
			
			const remove = function( a, value ) {
				return a.filter(v=>value!=v);
			}

			const randomPick = function( a ) {
				return a[ Math.floor( Math.random() * a.length ) ];
			};

			window.onload = boardBuilder;
		</script>
	</HEAD>
	<BODY>
	</BODY>
</HTML>
