<HTML>
	<HEAD>
		<TITLE>boardBuilder</TITLE>

		<style>
			body {
				font-family: Comic Sans MS, sans;
			}
			img {
				display:block;
				position:absolute;
			}
		</style>

		<script type="text/javascript" src="tiles.js"></script>
		<script type="text/javascript" src="directions.js"></script>

		<script type="text/javascript">
			const boardBuilder = function() {
				let start = "Borderland";
				let placed = [ addTile( start ) ];

				let unplaced = shuffle( remove( Object.keys( tiles ), start ) );

				for ( let i = 0 ; i < 999 && unplaced.length ; i++ ) {
					unplaced = shuffle( unplaced );

					let pick = randomPick( placed );
					let exits = [];
					for ( let k in pick.exits ) {
						if ( !pick.exits[ k ] ) exits.push( k );
					}
					if ( 0 == exits.length ) {
						console.log( pick.name + ' has no available exits, moving on...' );
						continue;
					}

					shuffle( exits );
					console.log( 
						  'try to place something near ' 
						+ pick.name 
						+ ' @( ' + [pick.tileX,pick.tileY].join( ',' ) + ')' 
						+ ' via ' + exits.join( ', ' ) 
					);

					let foundOne = false; 

					for ( let e = 0 ; e < exits.length && !foundOne; e++ ) {
						let exit = exits[ e ];
						let opposing = DIRECTIONS[ exit ].opposing;
						console.log( '- ' + exit + ' leads to ' + opposing );

						for ( let j = 0 ; j < unplaced.length ; j++ ) {
							let maybe = unplaced[ j ];
							let to = tiles[ maybe ].normal.exits;
							if ( !( opposing in to ) ) {
								// this is pretty tmi...
								//console.log( '-- ' + maybe + ' tile has no exits headed that way' );
								continue;
							}

							let x = pick.tileX + egz( DIRECTIONS[ exit ].dx );
							let y = pick.tileY + egz( DIRECTIONS[ exit ].dy );

							console.log( '-- could be ' + maybe + ' @(' + [x,y] + ') from ' + exit + ' to ' + opposing );

							foundOne = canPlace( maybe, x, y, placed );;
							if ( !foundOne ) {
								console.log( '>> rejecting ' + maybe );
								continue;
							}

							let picked = addTile( maybe, pick, exit );
							placed.push( picked );
							unplaced = remove( unplaced, maybe );

							console.log( '-> added ' + maybe + ' as #' + placed.length + ' pick' );
							console.log( '> ' +
								pick.name + '@' 
							+ [pick.tileX,pick.tileY].join( ',' ) + ' -> ' + exit 
							+ ' -> ' + opposing + ' <- ' + maybe + '@' + [picked.tileX,picked.tileY].join( ',' )

							);
							console.log( '-----------------------------------------------------------------------------' );

							break;
						}
					}

//					break;
				}

				showBoard( placed );
				console.log( 'unplaced: ' + unplaced.length );
			};

			const showBoard = function( placed ) {
				//console.log( JSON.stringify( placed ) );

				let w = 497;
                let h = 431;

				let minx = 0;
				let miny = 0;
				for ( let i = 0 ; i < placed.length ; i++ ) {
					if ( placed[ i ].x < minx ) minx = placed[ i ].x;
					if ( placed[ i ].y < miny ) miny = placed[ i ].y;
				}
				console.log( [minx,miny].join( ', ' ) );

				for ( let i = 0 ; i < placed.length ; i++ ) {
					let fun = placed[ i ];
					let tile = tiles[ fun.name ];

					let img = document.createElement( 'img' );
					img.src = tile.normal.image;
					img.style.top  = h * ( -miny + fun.y ) + 'px';
					img.style.left = w * ( -minx + fun.x ) + 'px';
					document.body.appendChild( img );
				};
			};
						
			const canPlace = function( maybe, tileX, tileY, placed ) {
				let ok = true;

				let tile = tiles[ maybe ].normal;

				// make sure nothing else is already here (oopsie!)
				for ( let i = 0 ; i < placed.length && ok ; i++ ) {
					if ( tileX == placed[ i ].tileX && tileY == placed[ i ].tileY ) {
						console.log( '>>> ' + maybe + ' would overlay ' + placed[ i ].name + ' at ' + [tileX,tileY] );
						ok = false; 
					}
				}

				for ( let direction in DIRECTIONS ) {
					let otherX = tileX + egz( DIRECTIONS[ direction ].dx );
					let otherY = tileY + egz( DIRECTIONS[ direction ].dy );
					let other = false;

					let tileExit  = ( direction in tile.exits  ) ? 'exit' : 'non-exit';
					let tmi1 = [maybe,direction,tileExit].join( '.' );

					for ( let i = 0 ; i < placed.length && !other ; i++ ) {
						if ( otherX ==  placed[ i ].tileX && otherY == placed[ i ].tileY ) {
							other = placed[ i ];
						}
					}

					if ( !other ) {
						console.log( '---- nothing to check ' + tmi1 + ' -> ' + [otherX,otherY].join( '.' ) );
						continue;
					}

					let opposing = DIRECTIONS[ direction ].opposing;
					let otherExit = ( opposing  in other.exits ) ? 'exit' : 'non-exit';
					let tmi2 = [other.name,opposing,otherExit].join( '.' );

					ok = ( tileExit == otherExit );
					console.log( '---- check ' + tmi1 + ' vs ' + tmi2 + ' -> ' + ok );
					if ( !ok ) break;
				}

				return ok;
			};

			const egz = function( v ) {
				return v;
				return v < -0.33 ? -1 : ( v > +0.33 ? +1 : 0 );
			}

			const addTile = function( name, which, from ) {
				// TODO: handle orientation properly
				let tile = {name:name, x:0, y:0, tileX:0, tileY:0, orientation:0, exits:{}};

				if ( from && which ) {
					tile.x = which.x + DIRECTIONS[ from ].dx;
					tile.y = which.y + DIRECTIONS[ from ].dy;
					tile.tileX = which.tileX + egz( DIRECTIONS[ from ].dx );
					tile.tileY = which.tileY + egz( DIRECTIONS[ from ].dy );

					if ( which.exits[ from ] ) {
						throw which.name + '.' + from + ' leads to ' + which.exits[ from ] + ' already';
					} else {
						which.exits[ from ] = name;
					}
				}

				for ( let k in tiles[ name ].normal.exits ) {
					tile.exits[ k ] = (
						( which && from && k == DIRECTIONS[ from ].opposing ) 
						? which.name
						: false
					);
					
					// TODO: see if any other exits need to be hooked up....
				}
				console.log( '--> ' + JSON.stringify( tile ) );

				return tile;
			};

			const shuffle = function( a ) {
				return a.sort((x,y)=>Math.random()-Math.random());
			}
			
			const remove = function( a, value ) {
				return a.filter(v=>value!=v);
			}

			const randomPick = function( a ) {
				return a[ Math.floor( Math.random() * a.length ) ];
			};

			window.onload = boardBuilder;
		</script>
	</HEAD>
	<BODY>
	</BODY>
</HTML>
