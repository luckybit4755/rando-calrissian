<HTML>
	<HEAD>
		<TITLE>boardBuilder</TITLE>

		<style>
			body {
				font-family: sans-serif;
				xbackground:url('oddq-hex.png');
				overflow:scroll;
			}
			img {
				display:block;
				position:absolute;
			}
			.r0 { transform: rotate( -0deg ); }
			.r1 { transform: rotate( -60deg ); }
			.r2 { transform: rotate( -120deg ); }
			.r3 { transform: rotate( -180deg ); }
			.r4 { transform: rotate( -240deg ); }
			.r5 { transform: rotate( -300deg ); }
			canvas {
				position:absolute;
				z-index:33;
				color:yellow;
			}
		</style>

		<script type="text/javascript" src="tiles.js"></script>
		<script type="text/javascript" src="directions.js"></script>

		<script type="text/javascript">
			/* this is a bit squirrely */
			let themLogs = [];
			let whozLogs = {};

			const boardBuilder = function() {
				let board = false;
			
				let maxTries = 300;	
				let attempt = 0;

				for ( attempt = 0 ; attempt < maxTries ; attempt++ ) {
					board = buildBoard();
					if ( !Object.keys( board.unreachable ).length && !board.unplaced.length ) {
						break;
					} else {
if ( 1 == maxTries ) break;
						board = false;
					}
				}

				if ( 1 != maxTries && !board ) {
					document.body.innerHTML = 'completely failed to build a board after ' + attempt + ' tries, sorry';
					return;
				}

				showBoard( board.placed );

				let nfo = document.createElement( 'pre' );
				nfo.style.top = '1em';
				nfo.style.left = '1em';
				nfo.style.position = 'absolute';
				nfo.style.zIndex = 66;
				nfo.style.background = 'white';
				nfo.appendChild( document.createTextNode( 
					'built a fully connected board after ' + attempt + ' tries' 
				) );

				document.body.appendChild( nfo );
			};

			const buildBoard = function() {
				let start = "Borderland";
				let orientation = randomOrientation();
				let placed = [ addTile( start, orientation ) ];

				let unplaced = shuffle( remove( Object.keys( tiles ), start ) );

				for ( let i = 0 ; i < 99 && unplaced.length ; i++ ) {
					let origin = randomPick( placed );

					unplaced = shuffle( unplaced );

					let exits = [];
					for ( let exit in origin.exits ) {
						if ( !origin.exits[ exit ] ) {
							let neighborAt = findTileAt( placed, Hexactions.offset( origin.at, exit ) );
							if ( neighborAt ) {
								//throw 'ERROR: tile collision ' + neighborAt.name;
								origin.exits[ exit ] = neighborAt.name; // ????
								continue;
							}

							exits.push( exit );
						}
					}
					if ( 0 == exits.length ) {
						//log( origin.name + ' has no available exits, moving on...' );
						i--; // don't count this attempt
						continue;
					}
					shuffle( exits );

					let foundOne = false; 

					for ( let e = 0 ; e < exits.length && !foundOne; e++ ) {
						let exit = exits[ e ];
						let point = Hexactions.offset( origin.at, exit );
						let opposite = Hexactions.opposite( exit );

						log( 
							'start.%1> %2 @ %3 + %4 -> %5 <- %6 from %7'
							.replace( /%1/, i )
							.replace( /%2/, origin.name )
							.replace( /%3/, ptToTxt( origin.at ) )
							.replace( /%4/, exit )
							.replace( /%5/, ptToTxt( point ) )
							.replace( /%6/, opposite )
							.replace( /%7/, unplaced.join( ',' )  )
						);


						for ( let j = 0 ; j < unplaced.length ; j++ ) {
							let maybe = unplaced[ j ];
							orientation = randomOrientation();

							let to = rotateExits( tiles[ maybe ].normal.exits, orientation );
							if ( !( opposite in to ) ) {
								// this is pretty tmi...
								//log( '-- ' + maybe + ' tile has no exits headed ' + opposite );
								continue;
							}

							log( '-- could be ' + maybe + ' @(' + ptToTxt ( point ) + ') going ' + exit + ' to the ' + opposite );

							foundOne = canPlace( maybe, point, to, placed );;
							if ( !foundOne ) {
								log( '>> rejecting ' + maybe );
								continue;
							}

							let toAdd = addTile( maybe, orientation, origin, exit, placed );
							placed.push( toAdd );
							unplaced = remove( unplaced, maybe );

							log(
								'- added %1 as tile #%2 @ %3 %4 connected to %5 from %6 at %7'
								.replace( /%1/, maybe )
								.replace( /%2/, placed.length )
								.replace( /%3/, ptToTxt( toAdd.at ) )
								.replace( /%4/, opposite )
								.replace( /%5/, exit )
								.replace( /%6/, origin.name )
								.replace( /%7/, ptToTxt( origin.at ) )
							)
							log( '-----------------------------------------------------------------------------' );
							saveLog( maybe );

							break;
						}
						foundOne = false; // maybe this will lead to denser maps?
					}
				}

				let unreachable = traceOut( placed );

				return { placed:placed, unreachable:unreachable, unplaced:unplaced };
			};

			const randomOrientation = function() {
				return Math.floor( 33 * Math.random() ) % 6;
			};

			// aka drawBoard
			const showBoard = function( placed ) {
				//log( JSON.stringify( placed, false, '\t' ) );

				let w = 497;
                let h = 431;

				let minx = 0;
				let miny = 0;
				for ( let i = 0 ; i < placed.length ; i++ ) {
					let at = placed[ i ].at;
					if ( at.x < minx ) minx = at.x;
					if ( at.y < miny ) miny = at.y;
				}
				minx *= -w;
				miny *= -h;
				log( [minx,miny].join( ', ' ) );
			
				// this is a bit wack...	
				let wq = w * ( 0.49 + 0.00 )
				let hq = h * ( 0.57 + 0.00 )

				let radius = 170;
				//radius = 0; // cheesy way to turn off debugging

				let green = '#0F0';

				for ( let i = 0 ; i < placed.length ; i++ ) {
					let hex = placed[ i ];
					let at = Hexactions.toScreen( hex.at, wq, hq );
					at.x += minx;
					at.y += miny;

					let tile = tiles[ hex.name ];

					let img = document.createElement( 'img' );
					img.src = tile.normal.image;
					img.setAttribute( 'class',  'r' + hex.orientation );
					document.body.appendChild( positionElement( img, at, w, h ) );

					if ( !radius ) continue;

					let tmi = document.createElement( 'canvas' );
					document.body.appendChild( positionElement( tmi, at, w, h ) );
					let context = tmi.getContext( '2d' );
					tmi.onclick = function() {
						console.log( '--------------------------------------------' );
						console.log( whozLogs[ hex.name ].join( '\n' ) );
						console.log( 'ok: ' + hex.name );
					}

					context.font = '24px Arial';
					context.fillStyle = 'white';
					let lw = 6;
					let lh = 24;

					let msg = '#' + i + ':' + hex.name + ': ' + ptToTxt( hex.at );
					let x = w / 2 - lw * msg.length;
					let y = h / 2;
					context.fillText( msg, x, 44 );

					context.font = '24px Arial';
					let clearings = Object.keys( tiles[ hex.name ].normal.clearings );
					for( let j = 0 ; j < clearings.length ; j++ ) {
						let clearing = clearings[ j ];
						let distance = hex.distances[ clearing ];
						if ( distance < 0 ) {
							context.fillStyle =  '#FDD';
							distance = '!'
						} else {
							context.fillStyle = green;
						}

						msg = clearing + ':' + distance ;
						//context.fillText( msg, x, y + lh );
						x += 5 * lw;

						let point = tiles[ hex.name ].normal.clearings[ clearing ];
						point.x = point.x / 100 - 0.5;
						point.y = point.y / 100 - 0.5;
						let length = Math.sqrt( ( point.x * point.x ) + ( point.y * point.y ) );

						let angle = Math.atan2( -point.y, point.x );
						angle += hex.orientation * Math.PI / 3;

						x = w / 2 + Math.cos( angle ) * length * w;
						y = h / 2 - Math.sin( angle ) * length * h;
						context.fillText( msg, x, y );
					}

					// below here is the stuff I used to debug the exit vs non-exit stuff
					if ( !false ) continue;

					for ( direction in hex.exits ) {
						let to = hex.exits[ direction ];
						let angle = Hexactions.angle( direction );
						let x = w / 2 + radius * Math.cos( angle ); 
						let y = h / 2 - radius * Math.sin( angle ); 
							
						let nAt = Hexactions.offset( hex.at, direction );
						let msg = direction + ': '+ ptToTxt( nAt );

						if ( to ) { 
							context.fillStyle = 'cyan';
							context.fillText( msg, x, y );
							context.fillText( to, x, y + 32 );
						} else {
							context.fillStyle = green;
							context.fillText( msg, x, y );
						}
					}
				};
			};

			const positionElement = function( element, at, w, h ) {
				element.width = w;
				element.height = h;
				element.style.left   = at.x + 'px';
				element.style.top    = at.y + 'px';
				element.style.width  = w + 'px';
				element.style.height = h + 'px';
				return element;
			};
						
			const canPlace = function( maybe, point, exits, placed ) {
				let ok = true;

				// make sure nothing else is already here (oopsie!)
				for ( let i = 0 ; i < placed.length && ok ; i++ ) {
					if ( point.x == placed[ i ].at.x && point.y == placed[ i ].at.y ) {
						log( '>>> ' + maybe + ' would overlay ' + placed[ i ].name + ' at ' + point );
						ok = false; 
					}
				}

				for ( let direction in DIRECTIONS ) {
					let dilection = direction;
					if ( 1 == dilection.length ) dilection += '_';

					let tileExit  = ( direction in exits ) ? 'isa-exit' : 'non-exit';
					let tmi1 = [maybe,dilection,tileExit].join( '.' );

					let otherAt = Hexactions.offset( point, direction );
					let other = findTileAt( placed, otherAt );

					if ( !other ) {
						log( '---- deserted ' + tmi1 + ' -> ' + ptToTxt( otherAt ) );
						continue;
					}

					let opposite = Hexactions.opposite( direction );
					let otherExit = ( opposite  in other.exits ) ? 'isa-exit' : 'non-exit';
					let tmi2 = [other.name,opposite,otherExit].join( '.' );

					ok = ( tileExit == otherExit );
					log( '---' + ( ok ? '- matching ' : '> conflict ' ) + tmi1 + ' vs ' + tmi2 );
					if ( !ok ) break;
				}

				log( '-- no conflicts detected for ' + maybe + ' @ ' + ptToTxt( point ) );

				return ok;
			};

			const findTileAt = function( placed, otherAt ) {
				for ( let i = 0 ; i < placed.length ; i++ ) {
					let there = placed[ i ];
					if ( otherAt.x == there.at.x && otherAt.y == there.at.y ) {
						return there;
					}
				}
				return false;
			};

			const addTile = function( name, orientation, tileFrom, directionFrom, placed ) {
				log( 
					'-- adding %1 from %2.%3'
					.replace( /%1/, name )
					.replace( /%2/, tileFrom ? tileFrom.name : 'na' )
					.replace( /%3/, directionFrom || 'na' )
				);

				let n = 0;
				let tile = {name:name, at:{x:n,y:n}, orientation:orientation, exits:{}};

				if ( directionFrom && tileFrom ) {
					tile.at = Hexactions.offset( tileFrom.at, directionFrom );
					if ( tileFrom.exits[ directionFrom ] ) {
						throw tileFrom.name + '.' + directionFrom + ' leads to ' + tileFrom.exits[ directionFrom ] + ' already';
					} else {
						tileFrom.exits[ directionFrom ] = name;
					}
				}

				let rotatedExits = rotateExits( tiles[ name ].normal.exits, orientation );
				for ( let exit in rotatedExits ) {
					if ( !tileFrom ) {
						log( '--- no from tile, must be Borderland' );
						tile.exits[ exit ] = false;
						continue;
					}

					let value = false;
					if ( exit == Hexactions.opposite( directionFrom ) ) {
						value = tileFrom.name;
						log( '--- from ' + exit + ' is ' + tileFrom.name );
					} else {
						let neighborAt = Hexactions.offset( tile.at, exit );
						let neighbor = findTileAt( placed, neighborAt );
						if ( neighbor ) {
							value = neighbor.name;
							log( '--- neighbor exists ' + exit + ' at ' + ptToTxt( neighborAt ) + ' ' + value );
							let opposite = Hexactions.opposite( exit );
							if( neighbor.exits[ opposite ] && name != neighbor.exits[ opposite ] ) { 
								log( '--> WARNING: ' + value + ' already has a neighbor at ' + opposite + ': ' + neighbor.exits[ opposite ] );
							} else {
								neighbor.exits[ opposite ] = name;
								log( '--- update: ' + value + '.' + opposite + ' to be ' + name );
							}
						} else {
							log( '--- no neighbor to ' + exit + ' at ' + ptToTxt( neighborAt ) );
						}
					}

					tile.exits[ exit ] = value;
				}
				log( '-- ' + JSON.stringify( tile ) );

				return tile;
			};

			const traceOut = function( placed ) {
				let names = {};
				for ( let i = 0 ; i < placed.length ; i++ ) {
					let hex = placed[ i ];
					names[ hex.name ] = hex;
					hex.distances = {};
					for ( let clearing in tiles[ hex.name ].normal.clearings ) {
						hex.distances[ clearing ] = 'Borderland' === hex.name ? 0 : -1;
					}
					hex.entrances = rotateExits( tiles[ hex.name ].normal.exits, hex.orientation );
				}

				let visited = [ 'Borderland' ];

				for ( let sanity = 999 ; sanity > 0 ; sanity-- ) {
					let nu = {};
					for ( let i = 0 ; i < visited.length ; i++ ) {
						let name = visited[ i ];
						let hex = names[ name ];

						for ( let exit in hex.exits ) {
							let clearing = hex.entrances[ exit ];
							let distance = hex.distances[ clearing ];
							if ( distance < 0 ) continue;

							log( name + '.' + exit + ' -> ' + clearing + ' distance is  '+ distance );
							distance++;

							let neighbor = hex.exits[ exit ];
							if ( !neighbor ) continue;

							let opposite = Hexactions.opposite( exit );
							neighbor = names[ neighbor ];

							log( 'try to update ' + neighbor.name + ' from ' + name + ':' + JSON.stringify( neighbor.distances ) );

							let start = neighbor.entrances[ opposite ];
							let paths = tiles[ neighbor.name ].normal.paths;
							let updated = connectClearings( start, distance, neighbor.distances, paths );

							if ( updated ) {
								nu[ neighbor.name ] = true;
								log( neighbor.distances );
							}
							log( 'dfq: ' + updated + ' so ' + Object.keys( nu ) );
						}

						log( 'new blood:' + Object.keys( nu ) );
					}

					visited = Object.keys( nu );
					if ( 0 == visited.length ) {
						log( 'all out of love' );
						break;
					}
				}

				let unreachable = {};

				for ( let i = 0 ; i < placed.length ; i++ ) {
					let hex = placed[ i ];
					let unreached = [];
					for ( let clearing in hex.distances ) {
						let distance = hex.distances[ clearing ];
						if ( distance < 0 ) {
							unreached.push( clearing );
						}
					}
					if ( unreached.length ) {
						unreachable[ hex.name ] = unreached;
					}
				}

				return unreachable;
			};

			const closer = function( current, distance ) {
				return ( current < 0 || distance < current ) ? distance : current;
			};
			const updateDistance = function( clearing, distances, distance ) {
				let b4 = distances[ clearing ];
				distances[ clearing ] = closer( b4, distance );
				return b4 != distances[ clearing ];
			};

			// this is still not right...
			const connectClearings = function( start, distance, distances, paths ) {
				let updated = updateDistance( start, distances, distance );
				let connected = {};
				connected[ start ] = distances[ start ];

				log( 'update ' + start + ' to ' + distances[ start ] + ' using ' + distance );

				// another scaredy-cat loop
				for( let qqq = 0 ; qqq < 333 ; qqq++ ) {
					let addedClearing = false;
					for( let j = 0 ; j < paths.length ; j++ ) {
						let path = paths[ j ].clearings;
						log( '- check ' + path );

						let addClearings = false;
						let addEm = false;
						
						for ( let p = 0 ; p < path.length && !addEm ; p++ ) {
							let c = path[ p ];
							if( c in connected ) {
								log( '- hit on ' + c + ' at distance:' + distance );
								addEm = connected[ c ] + 1;
								break;
							}
						}
						if ( !addEm ) continue;

						for ( let p = 0 ; p < path.length ; p++ ) {
							let c = path[ p ];
							if ( c in connected ) continue;

							log( '-- so add ' + c + ' at ' + addEm );
							addedClearing = true;
							updated = updateDistance( c, distances, addEm ) || updated;
							log( '-- so  ' + c + ' is now ' + distances[ c ] );
							connected[ c ] = distances[ c ];
						}
					}
					if ( !addedClearing ) {
						log( 'done and updated is ' + updated );
						break;
					}
				}

				log( '----' );
				return updated;
			}
	
			const rotateExits = function( exits, orientation ) {
				let rotated = {};
				for ( let direction in exits ) {
					rotated[ Hexactions.rotate( direction, orientation ) ] = exits[ direction ];
				}
				return rotated;
			};

			const shuffle = function( a ) {
				return a.sort((x,y)=>Math.random()-Math.random());
			};
			
			const remove = function( a, value ) {
				return a.filter(v=>value!=v);
			};

			const randomPick = function( a ) {
				return a[ Math.floor( Math.random() * a.length ) ];
			};

			const ptToTxt = function( p ) {
				return p.x + ',' + p.y;
			};

			const log = function( x ) {
				return;
				console.log( x );
				themLogs.push( x );
			};

			const saveLog = function( whoz ) {
				whozLogs[ whoz ] = themLogs;
				themLogs = [];
			};

			window.onload = boardBuilder;
		</script>
	</HEAD>
	<BODY>
	</BODY>
</HTML>
