<HTML>
	<HEAD>
		<TITLE>cloudy-mountains</TITLE>

		<style>
			body {
				font-family: Comic Sans MS, sans;
				background:black;
				margin:2em;
			}
			canvas {
				border:  1px solid #888;
				margin:  auto;
				display: block;
			}
		</style>

		<script type="text/javascript" src="js/functions.js"></script>
		<script type="text/javascript">
			const r = function() {
				return Math.random();
			};

			const CloudyMountains = function() {
				let self = this;

				self.init = function() {
					self.canvas = getByTag( 'canvas' );
					self.context = self.canvas.getContext( '2d' );
					self.size = parseInt( self.canvas.width );
					self.tileSize = 8;
					self.tileSize = 16;
					self.tileSize = 2;
					self.tileSize = 4;
					self.tileSize = 8;

					self.angle = 0;
					self.raw = !false;
					self.canvas.onclick = function() {
						self.angle++;
						if ( self.raw ) {
							self.raw = false;
							self.angle = 0;
						}
					};
					document.onkeypress = function( e ) {
						switch ( e.key ) {
							case 'r': self.raw = !self.raw; break;
						};
					};

					self.statisticsDrawing = { time:0, count: 0};

					self.initializeClouds();
					self.makeClouds( 0, 0, self.size / self.tileSize );
					self.cloudRanger();
					self.screened();

					self.frameFunction = frame( self.draw, 24 );
					self.frameFunction.start();
					self.draw();
				};

				self.initializeClouds = function() {
					let n = self.size / self.tileSize;

					self.cloud = self.nu2dArray( n );

					let m = n - 1;
					self.cloud[ 0 ][ 0 ] = r();
					self.cloud[ m ][ 0 ] = r();
					self.cloud[ m ][ m ] = r();
					self.cloud[ 0 ][ m ] = r();
				};

				self.nu2dArray = function( n ) {
					let ar = new Array( n );
					for ( let i = 0 ; i < n ; i++ ) {
						ar[ i ] = new Array( n );
					}
					return ar;
				};

				// offset the midpoints a little and recurse
				self.makeClouds = function( x1, y1, size ) {
					if ( size < 2 ) return;

					let C = self.cloud;

					let x2 = x1 + size - 1;
					let y2 = y1 + size - 1;

					let top    = 0.5 * ( C[ x1 ][ y1 ] + C[ x2 ][ y1 ] );
					let left   = 0.5 * ( C[ x1 ][ y1 ] + C[ x1 ][ y2 ] );
					let right  = 0.5 * ( C[ x2 ][ y1 ] + C[ x2 ][ y2 ] );
					let bottom = 0.5 * ( C[ x1 ][ y2 ] + C[ x2 ][ y2 ] );

					let f = size / ( self.cloud.length * 2 );

					let nu_top    = top    - r() * f;
					let nu_left   = left   - r() * f;
					let nu_right  = right  - r() * f;
					let nu_bottom = bottom - r() * f;

					let nu = 0.25 * ( nu_top + nu_left + nu_right + nu_bottom ) - r() * f;

					let size2 = size / 2;

					let xm1 = x1 + size2 - 1;
					let xm2 = x1 + size2 - 0;
					let ym1 = y1 + size2 - 1;
					let ym2 = y1 + size2 - 0;

					// (x1,y1)     (xm1,y1) (xm2,y1)          (x2,y1)
					//
					// (x1,ym1)    (xm1,ym1) (xm2,ym1)        (x2,ym1)
					// (x1,ym2)    (xm1,ym2) (xm2,ym2)        (x2,ym2)
					//
					// (x1,y2)     (xm1,y2)v(xm2,y2)          (x2,y2)

					C[ xm1 ][ y1 ] = C[ xm2 ][ y1 ] = nu_top;

					C[ x1 ][ ym1 ] = C[ x1 ][ ym2 ] = nu_left;
					C[ x2 ][ ym1 ] = C[ x2 ][ ym2 ] = nu_right;

					C[ xm1 ][ y2 ] = C[ xm2 ][ y2 ] = nu_bottom;

					C[ xm1 ][ ym1 ] = C[ xm2 ][ ym1 ] = C[ xm1 ][ ym2 ] = C[ xm2 ][ ym2 ] = nu;

					// recurse

					self.makeClouds( x1, y1, size2 );
					self.makeClouds( xm2, y1, size2 );

					self.makeClouds( x1, ym2, size2 );
					self.makeClouds( xm2, ym2, size2 );
				};

				// scale points so they stay between 0 and 1
				self.cloudRanger = function() {
					let n = self.size / self.tileSize;

					let min = 9999999;
					let max = -min;
					for ( let y = 0 ; y < n ; y++ ) {
						for ( let x = 0 ; x < n ; x++ ) {
							let zed = self.cloud[ x ][ y ];
							if ( zed < min ) min = zed;
							if ( zed > max ) max = zed;
						}
					}

					let diff = max - min;
					for ( let y = 0 ; y < n ; y++ ) {
						for ( let x = 0 ; x < n ; x++ ) {
							let zed = self.cloud[ x ][ y ];
							self.cloud[ x ][ y ] = ( zed - min ) / diff;
						}
					}
				};

				self.now = function() {
					return new Date().getTime() / 1000.0;
				}

				self.draw = function() {
					let start = self.now();

					//self.drawBox();
					self.drawMountains();
					// self.drawLabels();	

					let stop = self.now();
					let diff = stop - start;

					self.statisticsDrawing.time += diff;
					self.statisticsDrawing.count++;
					if ( 1 == self.statisticsDrawing.count % 33 ) {
						self.statisticsInfo( 'draw', self.statisticsDrawing );
					}
				};

				self.statisticsInfo = function( label, statistics ) {
					let perFrame = Math.floor( statistics.time / statistics.count * 1000 ) / 1000;
					let fps = 1 / perFrame;
					console.log( 'draw: ' + perFrame + ' -> ' + fps + 'fps' );
				};

				self.drawBox = function() {
					let o = 0.05;
					let l = 1 - o;

					o = 0; l = 1;

					let p1, p2, p3, p4;

					// top and bottom of cube

					self.context.strokeStyle = 'green';
					p1 = self.toScreen( o, o, o ); p2 = self.toScreen( l, o, o );
					p4 = self.toScreen( o, l, o ); p3 = self.toScreen( l, l, o );
					self.drawPolygon( [p1,p2,p3,p4] );

					self.context.strokeStyle = 'blue'
					p1 = self.toScreen( o, o, o ); p2 = self.toScreen( l, o, o );
					p1 = self.toScreen( o, o, l ); p2 = self.toScreen( l, o, l );
					p4 = self.toScreen( o, l, l ); p3 = self.toScreen( l, l, l );
					self.drawPolygon( [p1,p2,p3,p4] );
				};

				// calculate color and screen coordinates for each point in the mountain
				self.screened = function() {
					self.screen = [];

					let n = self.size / self.tileSize;
					let blue  = [   0,   0, 255 ];
					let green = [   0, 255,   0 ];
					let brown = [  66,  37,  24 ];
					let gray  = [ 128, 128, 128 ];
					let white = [ 255, 255, 255 ];
					let water = 0.25;

					let epsilon = 0.0001;

					let colors = [
						  { z:-1.0, color:blue}
						, { z:water, color:blue}
						, { z:water+epsilon, color:green}
						, { z:0.30, color:green}
						, { z:0.37, color:brown}
						, { z:0.44, color:gray}
						, { z:0.74, color:gray}
						, { z:0.75, color:white}
						, { z:1.01, color:white}
					];

					// set the water level...
					for ( let y = 0 ; y < n ; y++ ) {
						for ( let x = 0 ; x < n ; x++ ) {
							if ( self.cloud[ x ][ y ] < water ) {
								self.cloud[ x ][ y ] = water - 0.001;
							}
						}
					}

					for ( let y = 0 ; y < n ; y++ ) {
						for ( let x = 0 ; x < n ; x++ ) {

							if ( !( x in self.screen ) ) {
								self.screen[ x ] = [];
							}

							let zed = self.cloud[ x ][ y ];
							let neighbor = ( 0 == x || 0 == y ) ? zed : self.cloud[ x - 1 ][ y - 1 ];
							let diff = ( zed - neighbor + 1 ) / 2;

							let v = Math.floor( 255 * diff );
							color = self.context.strokeStyle = 'rgb(v,v,v)'.replace( /v/g, v );

							let less = 0;
							let next = 0;
							for ( let i = 0 ; i < colors.length ; i++ ) {
								let cv = colors[ i ];
								if ( cv.z < zed ) {
									less = cv;
								}
								if ( cv.z > zed ) {
									next = cv;
									break;
								}
							}

							let color_zed = ( zed - less.z ) / ( next.z - less.z );
							// TODO: exponential instead of linear...

							let cv = [];
							for ( let i = 0 ; i < less.color.length; i++ ) {
								let a = less.color[ i ];
								let b = next.color[ i ];
								let c = a + ( b - a ) * color_zed;
								c = 0.33 * c + 0.77 * c * diff;
								cv.push( Math.floor( c ) );
							}

							//console.log( JSON.stringify( less ) + ' < ' + zed + ' < ' + JSON.stringify( next ) + ' so ' + color_zed + ' -> ' + cv );
							color = self.context.strokeStyle = 'rgb(' + cv.join( ',' ) + ')';

							//???zed = ( 0.00 * diff ) + ( 0.40 * zed );

							// little magic number 4u
							let point = self.toScreen( x / n, y /n, zed * 0.63 ); 

							self.screen[ x ][ y ] = {point:point,color:color,v:v,zed:zed,diff:diff,neighbor:neighbor,cv:cv};
						}
					}
				};

				self.clear = function() {
					self.context.fillStyle = 'black';
					self.context.fillRect( 0, 0, self.size, self.size );
				};

				self.rotate = function( x, y, cos, sin ) {
					// https://academo.org/demos/rotation-about-point/
					return {
						  x : ( x * cos ) - ( y * sin ) + 0.5
						, y : ( y * cos ) + ( x * sin ) + 0.5
					};
				}
				
				self.rawMountains = function() {
					let p1, p2, p3, p4;

					let n = self.size / self.tileSize;
					let l = 1 / self.cloud.length;

					let cos = Math.cos( self.angle );
					let sin = Math.sin( self.angle );
					self.angle += 0.08;

					let dy = -0.5;
					let dx = -0.5;

					self.clear();

					let imageData = self.context.getImageData( 0, 0, self.size, self.size );

					let zBuffer = self.nu2dArray( self.size );

					let half = self.size / 2;

					let lastRow = false;
					let thisRow = false;

					let theQ;

					for ( let y = 0 ; y < n ; y++, dy += l, lastRow = thisRow ) {
						thisRow = new Array( n );
						dx = -0.5;
						for ( let x = 0 ; x < n ; x++, dx +=l ) {
							let rotated = self.rotate( dx, dy, cos, sin );
/*
							if ( self.derpa[ x ][ y ] && self.derpa[ x ][ y ] < rotated.y ) {
								continue;
							} else {
								self.derpa[ x ][ y ] = rotated.y;
							}
*/

							let z = self.cloud[ x ][ y ];

							let point = self.toScreen( rotated.x, rotated.y, z );
							thisRow[ x ] = point;

							let ix = Math.floor( point.x );
							let iy = Math.floor( point.y );

							let cv = self.screen[ x ][ y ].cv;

							let index = 4 * ( ix + self.size * iy );

							for ( let j = 0 ; j < 3 ; j++, index += 4 * self.size  ) {
								imageData.data[ index + 0 ] = cv[ 0 ];
								imageData.data[ index + 1 ] = cv[ 1 ];
								imageData.data[ index + 2 ] = cv[ 2 ];
							}

							if ( !lastRow ) continue;
							if ( !x ) continue;

						   	// 
						   	//     p1 +---------+ p2 
						   	//        |         |
						   	// 
						   	// 
						   		   


							// this is a quick hacky polygon fill

							let theDrawn = [];

							if ( lastRow ) { 
								theDrawn.push( self.line2d( imageData.data, cv, point, lastRow[ x ], z,zBuffer ) ); 
								if ( 0 != x )  { 
									theDrawn.push( self.line2d( imageData.data, cv, lastRow[ x ], lastRow[ x - 1 ], z,zBuffer ) );
								}
							}
							if ( 0 != x )  { 
								theDrawn.push( self.line2d( imageData.data, cv, point, thisRow[ x - 1 ], z,zBuffer ) );
								if ( lastRow ) {
									theDrawn.push( self.line2d( imageData.data, cv, lastRow[ x - 1 ], thisRow[ x - 1 ], z,zBuffer ) );
								}
							}

							if ( theDrawn.length < 2 ) continue;
							
							let firstDrawn = theDrawn[ 0 ];
							for ( let i = 1 ; i < theDrawn.length ; i++ ) {
								let drawn = theDrawn[ i ];
								for ( let ky in drawn ) {
									if ( ky in firstDrawn ) {
										firstDrawn[ ky ] = firstDrawn[ ky ].concat( drawn[ ky ] );
									} else {
										firstDrawn[ ky ] = drawn[ ky ];
									}
								}
							}

							for( let ky in firstDrawn ) {
								let xz = firstDrawn[ ky ].sort();
								let x_min = xz[ 0 ];
								let x_max = xz[ xz.length - 1 ];
								for ( ; x_min <= x_max ; x_min++ ) {
									self.setPixel(imageData.data,cv,x_min,ky, z,zBuffer);
								}
							}
						}
					}

					self.context.putImageData( imageData, 0, 0 );

					self.context.fillStyle = 'red';
					let zeda = self.rotate( 0.5, 0.5, cos, sin );
				};
					
				self.drawMountains = function() {
					if ( self.raw ) {
						return self.rawMountains();
					}

					let p1, p2, p3, p4;

					let n = self.size / self.tileSize;
					let l = 1 / self.cloud.length;

					self.clear();

					//self.statisticsDrawing

					let directionals = [
						{ 
							  start: { x:1, y:1   }
						  	, stop:  { x:n, y:n   }
							, inc:   { x:1, y:1   }
							, side:  { x:1, y:n-1 }
							, add:{
								  p1: { x:-1, y:-1 }
								, p2: { x:-1, y:-0 }
								, p3: { x:-0, y:-0 }
								, p4: { x:-0, y:-1 }
							}
						}
						, 
						{ 
							  start: { x:n-2, y:n-2 }
						  	, stop:  { x:-1 , y:-1 }
							, inc:   { x:-1 , y:-1 }
							, side:  { x:1  , y:1}
							, add:{
								  p1: { x:+1, y:+1 }
								, p2: { x:+1, y:+0 }
								, p3: { x:+0, y:+0 }
								, p4: { x:+0, y:+1 }
							}
						}
					];

					self.angle = 0;
					let D = directionals[ self.angle % directionals.length ];

					for ( let ix = D.start.x ; ix != D.stop.x ; ix += D.inc.x ) {
						let x = ix;
						let xl = x * l;
						for ( let iy = D.start.y ; iy != D.stop.y ; iy += D.inc.y ) {
							let y = iy;

							if ( false && 1 == self.angle % directionals.length ) {
								//x = n - ix;
								//y = n - iy - 1;
//								console.log( ix + ' -> ' + x + ' and ' + iy + ' -> ' + y );
							}
							
							let yl = y * l;

	if ( 1 == self.angle % directionals.length ) {
//console.log( ' from ' + (x + D.add.p1.x) + ' and ' + ( x + D.add.p1.x) + ' cuz ' + x + ' + ' + D.add.p1.x );

	}
							p1 = self.screen[ x + D.add.p1.x ][ y + D.add.p1.y ];
	if ( 1 == self.angle % directionals.length ) {
//console.log( p1 + ' from ' + (x + D.add.p1.x) + ' and ' + ( y + D.add.p1.y) + ' cuz ' + y + ' + ' + D.add.p1.y );

	}
							p2 = self.screen[ x + D.add.p2.x ][ y + D.add.p2.y ];
							p3 = self.screen[ x + D.add.p3.x ][ y + D.add.p3.y ];
							p4 = self.screen[ x + D.add.p4.x ][ y + D.add.p4.y ];
							
							p1.point = self.toScreen( xl + D.add.p1.x * l, yl + D.add.p1.y * l, p1.zed );
							p2.point = self.toScreen( xl + D.add.p2.x * l, yl + D.add.p2.y * l, p2.zed );
							p3.point = self.toScreen( xl + D.add.p3.x * l, yl + D.add.p3.y * l, p3.zed );
							p4.point = self.toScreen( xl + D.add.p4.x * l, yl + D.add.p4.y * l, p4.zed );

							self.context.strokeStyle = p3.color;
							self.context.fillStyle = p3.color;
							self.drawPolygon( [p1.point,p2.point,p3.point,p4.point] );
							self.context.fill();

							// sides for front facing bits
							continue;

							if ( x == D.side.x ) {
								let y_1 = self.toScreen( xl + D.add.p1.x * l, yl + D.add.p1.x * l, 0 ).y;
								let y_2 = self.toScreen( xl + D.add.p2.x * l, yl + D.add.p2.y * l, 0 ).y; 

								//self.context.fillStyle = self.context.strokeStyle = 'gray';
								let toFloor = [p1.point,p2.point,{x:p2.point.x,y:y_2},{x:p1.point.x,y:y_1} ];
								self.drawPolygon( toFloor );
								self.context.fill();
							}

							if ( y == D.side.y ) {
								let y_2 = self.toScreen( xl + D.add.p2.x * l, yl + D.add.p2.y * l, 0 ).y; 
								let y_3 = self.toScreen( xl + D.add.p3.x * l, yl + D.add.p3.y * l, 0 ).y; 

								//self.context.fillStyle = self.context.strokeStyle = 'gray';
								let toFloor = [p2.point,p3.point,{x:p3.point.x,y:y_3},{x:p2.point.x,y:y_2} ];
								self.drawPolygon( toFloor );
								self.context.fill();
							}
						}
					}
				};

				self.drawLabels = function() {
					let o = 0.05;
					let l = 1 - o;

					self.context.fillStyle = 'red';
					self.text( '(0,0,0)', o,o,o );
					self.text( '(1,0,0)', l,o,o );
					self.text( '(0,1,0)', o,l,o );
					self.text( '(1,1,0)', l,l,o );
					self.text( '(0,0,1)', o,o,l );
					self.text( '(1,0,1)', l,o,l );
					self.text( '(0,1,1)', o,l,l );
					self.text( '(1,1,1)', l,l,l );
				};

				self.text = function( text, x, y, z ) {
					let point = self.toScreen( x, y, z );
					self.context.fillText( text, point.x, point.y + 2 );
				};

				self.drawLine = function( a, b ) {
					self.context.beginPath();
					self.context.moveTo( a.x, a.y );
					self.context.lineTo( b.x, b.y );
					self.context.closePath();
					self.context.stroke();
				};
				
				self.drawPolygon = function( points ) {
					self.context.beginPath();
					for ( let i = 0 ; i < points.length ; i++ ) {
						let point = points[ i ];
						if ( i ) {
							self.context.lineTo( point.x, point.y );
						} else {
							self.context.moveTo( point.x, point.y );
						}
					}

					self.context.closePath();
					self.context.stroke();
				};

				// magic numbers for everyone!
				self.toScreen = function( x, y, z ) {
					let value_x = 0.00 + ( +0.50 * x ) + ( +0.50 * y ) + ( +0.00 * z );
					let value_y = 0.84 + ( -0.15 * x ) + ( +0.15 * y ) + ( -0.69 * z );
					return { x:self.size * value_x , y:self.size * value_y }
				};

				// from https://stackoverflow.com/questions/4672279/bresenham-algorithm-in-javascript
				self.line2d = function( data, cv, p1, p2,  z,zBuffer ) {
					let drew = {};
					let x0 = Math.floor( p1.x );
					let y0 = Math.floor( p1.y );
					let x1 = Math.floor( p2.x );
					let y1 = Math.floor( p2.y );

					var dx = Math.abs(x1 - x0);
					var dy = Math.abs(y1 - y0);
					var sx = (x0 < x1) ? 1 : -1;
					var sy = (y0 < y1) ? 1 : -1;
					var err = dx - dy;

					while(true) {
						self.setPixel(data,cv,x0, y0,z,zBuffer); 
						if( y0 in drew ) {
							drew[ y0 ].push( x0 );
						} else {
							drew[ y0 ] = [ x0 ];
						}

						//if (Math.abs(x0 - x1) < 0.0001 && Math.abs(y0 - y1) < 0.0001) break;
						if ((x0 === x1) && (y0 === y1)) break;

						var e2 = 2*err;
						if (e2 > -dy) { err -= dy; x0  += sx; }
						if (e2 < dx) { err += dx; y0  += sy; }
					}

					return drew;
				};

				self.setPixel = function( data,cv,x,y, z,zbuffer ) {
					if ( zbuffer ) {
						if ( z < zbuffer[ x ][ y ] ) return;
						zbuffer[ x ][ y ] = z;
					}
					
					let index = 4 * ( x + y * self.size );
					data[ index + 0 ] = cv[ 0 ];
					data[ index + 1 ] = cv[ 1 ];
					data[ index + 2 ] = cv[ 2 ];
				};
	
				self.init();
			};

			window.onload = function() {
				new CloudyMountains();
			};
		</script>
	</HEAD>
	<BODY>
		<canvas width="512" height="512"></canvas>
	</BODY>
</HTML>
