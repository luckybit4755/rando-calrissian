<HTML>
	<HEAD>
		<TITLE>circo-mico</TITLE>

		<script type="text/javascript">
			const FPS = 24;
			const CMAX = 16777215;

			window.onload = function() {
				try {
					microphone_analyser_start();
				} catch( e ) {
					/* may need this if audio needs to be user initiated */
					let canvas = document.getElementsByTagName( 'canvas' )[ 0 ];
					canvas.getContext( '2d' ).fillText( 'click me', 33, 33 );
					canvas.onclick = function() { microphone_analyser_start() };
				};
			};

			const microphone_analyser_start = function() {
				/* request the microphone */
				navigator.mediaDevices.getUserMedia( { audio:true } )
				.then( function( microphone ) { 
					microphone_analyser_run( microphone );
				})
				.catch( function( err ) {
					console.log( 'could not get microphone access' );
					console.log( err );
				});
			};

			const microphone_analyser_run = function( microphone ) {
				/* get the web audio context */
				let audioContext = new AudioContext();

				/* setup the analyser and the data space */

				let analyser = audioContext.createAnalyser();
				let timeDomain = new Uint8Array( analyser.frequencyBinCount );
				let frequencies = new Uint8Array( analyser.frequencyBinCount );
				let angles = new Array( frequencies.length ).fill( 0 );

				/* connect it to the microphone using a stream */

				let microphone_stream = audioContext.createMediaStreamSource( microphone );
				microphone_stream.connect( analyser );

				/* get the canvas and context to draw stuff */

				let canvas = document.getElementsByTagName( 'canvas' )[ 0 ];
				let context = canvas.getContext( '2d' );

				document.body.onclick = document.body.onmouseover = document.body.keypress = document.onclick = document.onmouseover = document.keypress = canvas.onclick = canvas.on = function() { fullscreen( canvas ) }

				context.lineWidth = 2;
				
				/* draw some stuff */
					
				let frame = 0;

				let draw = function() {
					frame++;

					/* request next frame */

					setTimeout( function() { requestAnimationFrame( draw ); } , 1000 / FPS );

					/* analyse the data */

					analyser.getByteTimeDomainData( timeDomain );
					analyser.getByteFrequencyData( frequencies );

					/* clear the canvas */

					let w = canvas.width;
					let h = canvas.height;

					context.fillStyle = 'rgba(0,0,0,0.3)';
					context.fillRect(0, 0, w, h);

					/* draw the analysis */

					let rutro = 0;
					for ( let i = 0 ; i < frequencies.length ; i++ ) {
						rutro += frequencies[ i ];
					}

					rutro = 8 + w * 0.25 * ( rutro / 256 / frequencies.length );

					let x = w * 0.5 + Math.cos( frame / 10 ) * rutro;
					let y = h * 0.5 + Math.sin( frame / 10 ) * rutro;
					
					let mode = Math.floor( frame / 133 ) % 2;

					for ( let i = 0 ; i < frequencies.length ; i++ ) {
						let frequency = i % frequencies.length / frequencies.length;
						let volume = frequencies[ i ] / 256;

						let c = Math.floor( CMAX * frequency );
						
						let r = ( c >> 16 ) & 0xFF;
						let g = ( c >>  8 ) & 0xFF;
						let b = ( c >>  0 ) & 0xFF;
						let strokeStyle = 'rgb(x,x,x)'.replace( /x/, r ).replace( /x/, g ).replace( /x/, b );

						let a = 0.01 + 0.05;
						if ( mode ) {
							a *= 4.4;
						}
						let fillStyle = strokeStyle.replace( 'rgb', 'rgba' ).replace( /\)/, ',' + a +')' );

						context.strokeStyle = context.fillStyle = fillStyle;

						let radius = 2 + volume * w * 0.28; /* size of the circle */
						let offset = 4 + volume * w * 0.18; /* distance from the center (the 2 floats add up to < 0.5 ) */ 

						angles[ i ] += ( volume * volume ) - 0.5;
					
						x = w * 0.5 + Math.cos( angles[ i ] ) * offset;
						y = h * 0.5 + Math.sin( angles[ i ] ) * offset;

						context.beginPath();
						context.arc( x, y, radius, 0, 2 * Math.PI );
						if ( mode ) {
							context.stroke();
						} else { 
							context.fill();
						}
					}

					/* time domain graph */

					context.strokeStyle = 'rgba(255,0,0,0.2)';
					context.beginPath();

					let sliceWidth = w * 1.0 / timeDomain.length;

					x = 0;
					for ( let i = 0; i < timeDomain.length; i++, x+= sliceWidth ) {
						let y = h - h * ( timeDomain[ i ] / 256 ) * 0.1;
						( 0 === i ) ? context.moveTo( x, y ) : context.lineTo( x, y );
					}
					context.stroke();
				};

				/* initial call to draw function */

				draw();
			};

			const fullscreen = function( element ) {
				var fz = 'webkitRequestFullscreen requestFullScreen mozRequestFullScreen msRequestFullscreen webkitRequestFullscreen webkitRequestFullscreen'.split( ' ' );
				for ( var i = 0 ; i < fz.length ; i++ ) {
					var f = fz[ i ];
					if ( f in element ) {
						element[ f ]();
						break;
					}
				}
			};
		</script>
	</HEAD>
	<BODY>
		<canvas width="512" height="512"></canvas>
	</BODY>
</HTML>
